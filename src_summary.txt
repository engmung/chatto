
Directory: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\components


Directory: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\services


Directory: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\types


Directory: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\utils


File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\App.jsx

import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Scene3D from './components/Scene3D';
import ThemeText from './components/ThemeText';
import ChatInterface from './components/ChatInterface';
import StartGuide from './components/StartGuide';
import BackgroundMusic from './components/BackgroundMusic';
import { initialThemeData, generateThemeData } from './themes';
import { ArrowLeft, ArrowRight } from 'lucide-react';
import { sounds } from './utils/soundEffects';

const CONFIG = {
  GUIDE_SHOW_INTERVAL: 20000,    
  GUIDE_DURATION: 10000,         
  THEME_INACTIVE_TIMEOUT: 20000, 
  CHAT_INACTIVE_TIMEOUT: 40000   
};

const App = () => {
  const [currentState, setCurrentState] = useState('idle');
  const [currentTheme, setCurrentTheme] = useState(0);
  const [direction, setDirection] = useState(1);
  const [textState, setTextState] = useState('none');
  const [previousText, setPreviousText] = useState(null);
  const [currentText, setCurrentText] = useState(null);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [isChatOpen, setIsChatOpen] = useState(false);
  const [isChatClosing, setIsChatClosing] = useState(false);
  const [themes, setThemes] = useState(initialThemeData);
  const [hasKeyInteraction, setHasKeyInteraction] = useState(false);
  const [lastInteractionTime, setLastInteractionTime] = useState(Date.now());
  const [isActive, setIsActive] = useState(false);
  const [hasUserInteraction, setHasUserInteraction] = useState(false);
  const [lastActivityTime, setLastActivityTime] = useState(Date.now());

  const autoChangeInterval = useRef(null);
  const bounceAnimationRef = useRef(null);
  const inactivityTimerRef = useRef(null);
  const guideTimerRef = useRef(null);
  const directionRef = useRef(1);
  const lastInactiveTime = useRef(null);

  const clearAllTimers = () => {
  if (autoChangeInterval.current) {
    clearInterval(autoChangeInterval.current);
    autoChangeInterval.current = null;
  }
  if (inactivityTimerRef.current) {
    clearTimeout(inactivityTimerRef.current);
    inactivityTimerRef.current = null;
  }
  if (guideTimerRef.current) {
    clearTimeout(guideTimerRef.current);
    guideTimerRef.current = null;
  }
  lastInactiveTime.current = null;
};

  const startGuideTimer = () => {
    if (guideTimerRef.current) {
      clearTimeout(guideTimerRef.current);
    }
    
    if (currentState === 'idle' && !hasKeyInteraction) {
      guideTimerRef.current = setTimeout(() => {
        setHasKeyInteraction(true);
        setTimeout(() => {
          setHasKeyInteraction(false);
        }, CONFIG.GUIDE_DURATION);
      }, CONFIG.GUIDE_SHOW_INTERVAL);
    }
  };

  const checkAndResetInactivity = () => {
  if (!hasKeyInteraction && lastInactiveTime.current) {
    const currentTime = Date.now();
    const inactiveTime = currentTime - lastInactiveTime.current;
    const timeout = isChatOpen ? CONFIG.CHAT_INACTIVE_TIMEOUT : CONFIG.THEME_INACTIVE_TIMEOUT;

    if (inactiveTime >= timeout) {
      handleReset();
      lastInactiveTime.current = null;
    }
  }
};

  const startInactivityTimer = () => {
    if (inactivityTimerRef.current) {
      clearTimeout(inactivityTimerRef.current);
    }

    const timeout = isChatOpen ? CONFIG.CHAT_INACTIVE_TIMEOUT : CONFIG.THEME_INACTIVE_TIMEOUT;
    inactivityTimerRef.current = setTimeout(() => {
      handleReset();
    }, timeout);
  };

  const startAutoChange = () => {
    if (autoChangeInterval.current) {
      clearInterval(autoChangeInterval.current);
    }

    if (currentState === 'idle') {
      setDirection(1);
      directionRef.current = 1;
      
      autoChangeInterval.current = setInterval(() => {
        setCurrentTheme(prev => {
          if (prev === themes.length - 1) {
            setDirection(-1);
            directionRef.current = -1;
            return prev - 1;
          }
          else if (prev === 0) {
            setDirection(1);
            directionRef.current = 1;
            return prev + 1;
          }
          return prev + directionRef.current;
        });
      }, 7000);
    }
  };

  const startIdleMode = () => {
  clearAllTimers();
  setCurrentState('idle');
  setTextState('none');
  setThemes(generateThemeData());
  setCurrentTheme(0);
  setHasKeyInteraction(false);
  setIsActive(false);
  startAutoChange();
};

  window.resetToIdle = startIdleMode;

  const handleReset = () => {
  sounds.reset();
  setIsChatOpen(false);
  setIsChatClosing(true);

  // 채팅 인터페이스 애니메이션 완료 후 상태 리셋
  setTimeout(() => {
    setIsChatClosing(false);
    startIdleMode();
  }, 500);  // 채팅창 닫힘 애니메이션과 동일한 시간
};

  const handleInteraction = () => {
    setLastActivityTime(Date.now());
    
    if (currentState === 'idle') {
      setHasKeyInteraction(true);
      if (guideTimerRef.current) {
        clearTimeout(guideTimerRef.current);
      }
    }
  };

  // 테마 변경 시
const handleThemeChange = (changeDirection) => {
  handleInteraction();
  if ((currentState === 'active' || currentState === 'idle') && 
      !bounceAnimationRef.current && !isTransitioning) {
    const nextTheme = currentTheme + changeDirection;
    
    if (nextTheme < 0 || nextTheme >= themes.length) {
      return;
    }
    
    sounds.move();

    
    
    // 비전 처리 일시 중지 (매우 짧은 시간만)
    setTimeout(() => {
      // visionService.suspend();
    }, 100);
    
    if (currentState === 'active') {
      setIsTransitioning(true);
      setPreviousText(currentText);
      setCurrentText(themes[nextTheme].question);
      setTextState('transitioning');
    }
    
    setCurrentTheme(nextTheme);

    const textUpdateTimeout = setTimeout(() => {
      if (currentState === 'active') {
        setTextState('active');
        setIsTransitioning(false);
      }
    }, 900);

    if (currentState === 'idle') {
      startAutoChange();
      clearTimeout(textUpdateTimeout);
    }
  }
};


  const handleStateChange = () => {
    handleInteraction();
    sounds.select();
    lastInactiveTime.current = Date.now();
    
    if (currentState === 'active') {
      setIsChatOpen(true);
    } else {
      setTimeout(() => {
        setIsActive(true);
        setCurrentState('active');
        setCurrentText(themes[Math.round(currentTheme)].question);
        setTextState('entering');
        
        setTimeout(() => {
          setTextState('active');
        }, 1150);

        if (autoChangeInterval.current) {
          clearInterval(autoChangeInterval.current);
          autoChangeInterval.current = null;
        }
      }, );
    }
    
    handleInteraction();
  };

  const handleChatClose = () => {
    handleInteraction();
    sounds.close();
    setIsChatClosing(true);
    setIsChatOpen(false);
    setTimeout(() => {
      setIsChatClosing(false);
    }, 500);
  };

  useEffect(() => {
    const checkInterval = setInterval(() => {
      if (!hasKeyInteraction && (currentState === 'active' || isChatOpen)) {
        checkAndResetInactivity();
      }
    }, 1000);

    return () => clearInterval(checkInterval);
  }, [hasKeyInteraction, currentState, isChatOpen]);

  useEffect(() => {
  if (!hasKeyInteraction && (currentState === 'active' || isChatOpen)) {
    startInactivityTimer();
  }
}, [hasKeyInteraction, currentState, isChatOpen]);

  useEffect(() => {
    if (currentState === 'idle') {
      startAutoChange();
    }
    return () => clearAllTimers();
  }, [currentState]);

  useEffect(() => {
  const handleKeyPress = (e) => {
    handleInteraction();
    setHasUserInteraction(true);

    if (e.key === 'Escape') {
      if (isChatOpen || currentState === 'active') {
        handleReset();
      }
    }
    
    if (isChatOpen) return;

    if (currentState === 'idle' && (e.key === ' ' || e.key === 'Enter')) {
      handleStateChange();
    } else if (currentState === 'active') {
      if ((e.key === 'ArrowLeft' || e.key === 'a') && !isTransitioning) {
        handleThemeChange(-1);
      } else if ((e.key === 'ArrowRight' || e.key === 'd') && !isTransitioning) {
        handleThemeChange(1);
      } else if (e.key === ' ' || e.key === 'Enter') {
        handleStateChange();
      }
    } else if (currentState === 'idle') {
      if (e.key === 'ArrowLeft' || e.key === 'a') {
        handleThemeChange(-1);
      } else if (e.key === 'ArrowRight' || e.key === 'd') {
        handleThemeChange(1);
      }
    }
  };

  window.addEventListener('keydown', handleKeyPress);
  return () => window.removeEventListener('keydown', handleKeyPress);
}, [currentState, currentTheme, isTransitioning, isChatOpen]);

  useEffect(() => {
    if (currentState === 'idle') {
      startGuideTimer();
    }
    return () => {
      if (guideTimerRef.current) {
        clearTimeout(guideTimerRef.current);
      }
    };
  }, [currentState, hasKeyInteraction]);

  useEffect(() => {
    // idle 상태일 때는 타이머를 실행하지 않음
    if (currentState === 'idle') return;

    const inactivityCheck = setInterval(() => {
      const currentTime = Date.now();
      const inactiveTime = currentTime - lastActivityTime;
      const timeout = isChatOpen ? CONFIG.CHAT_INACTIVE_TIMEOUT : CONFIG.THEME_INACTIVE_TIMEOUT;

      if (inactiveTime >= timeout) {
        handleReset();
      }
    }, 1000);

    return () => clearInterval(inactivityCheck);
  }, [currentState, isChatOpen, lastActivityTime]);

  const renderDirectionArrows = () => {
  if (currentState !== 'active') return null;

  return (
    <AnimatePresence mode="sync"> {/* "wait"에서 "sync"로 변경 */}
      {!isChatOpen && (
        <motion.div 
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.5, ease: "easeInOut" }}
          className="fixed top-1/2 transform -translate-y-1/2 w-full px-8 flex justify-between pointer-events-none"
        >
          <AnimatePresence mode="sync"> {/* 여기도 "sync"로 설정 */}
            {currentTheme > 0 && (
              <motion.div 
                key="left-arrow"
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -20 }}
                transition={{ duration: 0.5, ease: "easeInOut" }}
                className="text-gray-600 animate-pulse"
              >
                <ArrowLeft size={64} strokeWidth={2.5} />
              </motion.div>
            )}
          </AnimatePresence>
          
          <div className="flex-grow" />
          
          <AnimatePresence mode="sync"> {/* 여기도 "sync"로 설정 */}
            {currentTheme < themes.length - 1 && (
              <motion.div 
                key="right-arrow"
                initial={{ opacity: 0, x: 20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: 20 }}
                transition={{ duration: 0.5, ease: "easeInOut" }}
                className="text-gray-600 animate-pulse"
              >
                <ArrowRight size={64} strokeWidth={2.5} />
              </motion.div>
            )}
          </AnimatePresence>
        </motion.div>
      )}
    </AnimatePresence>
  );
  };
  
  
  return (
    <div className="h-screen w-screen relative bg-white">
      <BackgroundMusic 
        currentState={currentState}
        isChatOpen={isChatOpen}
        volume={0.5}
        fadeTime={1000}
        hasInteraction={hasUserInteraction}
      />
      <Scene3D 
        currentState={currentState}
        currentTheme={Math.round(currentTheme)}
        isChatOpen={isChatOpen}
        themes={themes}
      />
      <StartGuide 
        isVisible={currentState === 'idle' && !hasKeyInteraction}
        currentState={currentState}
        onKeyInteraction={hasKeyInteraction}
      />
      <ThemeText
        textState={textState}
        currentText={currentText}
        previousText={previousText}
        currentTheme={currentTheme}
        isTransitioning={isTransitioning}
        themes={themes}
        isChatOpen={isChatOpen}
      />
      {renderDirectionArrows()}
      <ChatInterface 
        isOpen={isChatOpen}
        isClosing={isChatClosing}
        currentQuestion={themes[Math.round(currentTheme)].question}
        currentTheme={currentTheme}
        onClose={handleChatClose}
        themeColor={themes[Math.round(currentTheme)].color}
        onInteraction={handleInteraction}
      />
    </div>
  );
};

export default App;

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\index.css

@tailwind base;
@tailwind components;
@tailwind utilities;

html {
  overflow: hidden;
  height: 100%;
}

body {
  height: 100%;
  overflow: hidden;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: touch;
  touch-action: none;
}

#root {
  isolation: isolate;
}

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

// 브라우저 확대 설정 (중앙 기준)
// window.onload = function() {
//   const root = document.getElementById('root');
//   root.style.transform = "scale(1.125)";
//   root.style.transformOrigin = "center"; // 중앙 기준
//   root.style.position = "fixed";
//   root.style.width = "100%";
//   root.style.height = "100%";
//   root.style.top = "0";
//   root.style.left = "0";
  
//   // 스크롤바 방지
//   document.body.style.overflow = "hidden";
// }

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\themes.js

// themes.js
const positiveMemories = [
  {
    question: "최근에 가장 행복했던 순간은 언제인가요?",
    color: '#FF8C69'
  },
  {
    question: "지금 가장 감사한 것이 있다면 무엇인가요?",
    color: '#FFA07A'
  },
  {
    question: "최근에 누군가에게서 받은 친절한 행동이 있나요?",
    color: '#FFB07C'
  },
  {
    question: "스스로 칭찬하고 싶은 점이 있다면 무엇인가요?",
    color: '#FFD0A6'
  },
  {
    question: "가장 기대되는 일이 있다면 무엇인가요?",
    color: '#FFC590'
  }
];

const challengingMemories = [
  {
    question: "최근에 가장 어려웠던 결정은 무엇인가요?",
    color: '#7F7FFF'
  },
  {
    question: "지금 가장 해결하고 싶은 문제는 무엇인가요?",
    color: '#6B8EFF'
  },
  {
    question: "좌절감을 느꼈던 최근의 순간은 언제인가요?",
    color: '#5FA0FF'
  },
  {
    question: "스스로를 더 강하게 만들어준 경험이 있다면?",
    color: '#59B8FF'
  },
  {
    question: "다시 도전하고 싶은 일이 있다면 무엇인가요?",
    color: '#6FAFFF'
  }
];

const reflectiveMemories = [
  {
    question: "요즘 자주 생각하게 되는 것은 무엇인가요?",
    color: '#90EE90'
  },
  {
    question: "최근에 배운 가장 중요한 교훈은 무엇인가요?",
    color: '#A1F2A1'
  },
  {
    question: "자신의 성장에 대해 어떤 생각을 하시나요?",
    color: '#B3F7B3'
  },
  {
    question: "미래에 대한 가장 큰 희망은 무엇인가요?",
    color: '#C4FAC4'
  },
  {
    question: "스스로에게 해주고 싶은 말이 있다면 무엇인가요?",
    color: '#D8FFD8'
  }
];

function getRandomItem(array) {
  return array[Math.floor(Math.random() * array.length)];
}

function generateThemeData() {
  return [
    {
      id: 0,
      color: '#FF6B6B',
      question: "오늘 하루 중 가장 기분 좋았던 순간은?",
      floatingParams: { speed: 1, amplitude: 0.1, phase: 0 }
    },
    {
      id: 1,
      ...getRandomItem(positiveMemories),
      floatingParams: { speed: 0.8, amplitude: 0.15, phase: Math.PI / 3 }
    },
    {
      id: 2,
      ...getRandomItem(challengingMemories),
      floatingParams: { speed: 1.2, amplitude: 0.12, phase: Math.PI / 1.5 }
    },
    {
      id: 3,
      ...getRandomItem(reflectiveMemories),
      floatingParams: { speed: 0.9, amplitude: 0.14, phase: Math.PI / 2 }
    },
    {
      id: 4,
      color: '#4CAF50',
      question: "오늘 자신을 가장 뿌듯하게 했던 것은?",
      floatingParams: { speed: 1.1, amplitude: 0.13, phase: Math.PI / 2.5 }
    }
  ];
}

export const initialThemeData = generateThemeData();
export { generateThemeData };


File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\components\BackgroundMusic.jsx

import React, { useEffect, useRef, useState } from 'react';

const BackgroundMusic = ({ 
  currentState, 
  isChatOpen,
  volume = 0.5,
  fadeTime = 1000,
  hasInteraction = false 
}) => {
  const audioContextRef = useRef(null);
  const gainNodeRef = useRef(null);
  const sourceNodeRef = useRef(null);
  const [isInitialized, setIsInitialized] = useState(false);

  // AudioContext 초기화 및 오디오 재생 설정
  const initializeAudio = async () => {
    if (isInitialized || !hasInteraction) return;

    try {
      // AudioContext 생성
      audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
      
      // GainNode 설정
      gainNodeRef.current = audioContextRef.current.createGain();
      gainNodeRef.current.connect(audioContextRef.current.destination);
      gainNodeRef.current.gain.value = 0; // 초기 볼륨 0

      // 오디오 파일 로드
      const response = await fetch('/audio/background.wav');
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);

      // 소스 노드 생성 및 재생
      sourceNodeRef.current = audioContextRef.current.createBufferSource();
      sourceNodeRef.current.buffer = audioBuffer;
      sourceNodeRef.current.loop = true;
      sourceNodeRef.current.connect(gainNodeRef.current);
      sourceNodeRef.current.start(0);

      // 볼륨 페이드 인
      const now = audioContextRef.current.currentTime;
      gainNodeRef.current.gain.setValueAtTime(0, now);
      gainNodeRef.current.gain.linearRampToValueAtTime(volume * 0.6, now + 2);

      setIsInitialized(true);
    } catch (error) {
      console.error('Error initializing audio:', error);
    }
  };

  // 사용자 상호작용 감지 시 초기화
  useEffect(() => {
    if (hasInteraction && !isInitialized) {
      initializeAudio();
    }
  }, [hasInteraction]);

  // 상태에 따른 볼륨 조절
  useEffect(() => {
    if (!gainNodeRef.current || !isInitialized) return;

    let targetVolume = 0;

    if (currentState === 'idle') {
      targetVolume = volume * 0.6;
    } else if (currentState === 'active') {
      targetVolume = isChatOpen ? volume * 0.3 : volume;
    }

    const now = audioContextRef.current.currentTime;
    gainNodeRef.current.gain.linearRampToValueAtTime(
      targetVolume,
      now + (fadeTime / 1000)
    );
  }, [currentState, isChatOpen, volume, fadeTime, isInitialized]);

  // 클린업
  useEffect(() => {
    return () => {
      if (sourceNodeRef.current) {
        sourceNodeRef.current.stop();
      }
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
    };
  }, []);

  return null;
};

export default BackgroundMusic;

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\components\CameraController.jsx

import { useFrame, useThree } from '@react-three/fiber';
import * as THREE from 'three';

const CameraController = ({ currentState, currentTheme, spacing, centerOffset }) => {
  const { camera } = useThree();
  const lerpSpeed = 3; // 초당 보간 속도
  
  useFrame((state, delta) => {
    const targetX = (currentTheme * spacing) - centerOffset;
    const targetY = currentState === 'active' ? 1.42 : 0;
    const targetZoom = currentState === 'active' ? 500 : 200;
    
    // deltaTime을 이용한 보간
    const xDelta = (targetX - camera.position.x) * (currentState === 'active' ? 1.5 : 1.0) * lerpSpeed * delta;
    const yDelta = (targetY - camera.position.y) * 1.4 * lerpSpeed * delta;
    const zoomDelta = (targetZoom - camera.zoom) * lerpSpeed * delta;
    
    camera.position.x += xDelta;
    camera.position.y += yDelta;
    camera.zoom += zoomDelta;
    
    camera.rotation.set(0, 0, 0);
    camera.updateProjectionMatrix();
  });

  return null;
};

export default CameraController;

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\components\ChatInterface.jsx

import React, { useState, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Plus, Minus, X, Percent } from 'lucide-react';
import chatService from '../services/aiChatService';
import { sounds } from '../utils/soundEffects';

const LoadingDots = () => (
  <div className="flex space-x-2 items-center">
    {[0, 1, 2].map((i) => (
      <motion.span
        key={i}
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.5, repeat: Infinity, repeatType: "reverse", delay: i * 0.2 }}
        className="w-2 h-2 bg-gray-400 rounded-full"
      />
    ))}
  </div>
);

const getSessionStyling = () => {
  const ICONS = [Plus, Minus, X, Percent];
  const aiIconIndex = Math.floor(Math.random() * ICONS.length);
  let userIconIndex;
  do {
    userIconIndex = Math.floor(Math.random() * ICONS.length);
  } while (userIconIndex === aiIconIndex);
  
  const hue = Math.floor(Math.random() * 360);
  const userColor = `hsla(${hue}, 85%, 85%, 0.7)`;
  
  return {
    aiIcon: ICONS[aiIconIndex],
    userIcon: ICONS[userIconIndex],
    userColor,
  };
};

const ChatMessage = React.memo(({ 
  message, 
  isAI, 
  isLoading, 
  distance, 
  themeColor,
  sessionStyling 
}) => {
  const IconComponent = isAI ? sessionStyling.aiIcon : sessionStyling.userIcon;
  const backgroundColor = isAI 
    ? `rgba(${themeColor.replace('#', '').match(/.{2}/g).map(x => parseInt(x, 16)).join(', ')}, 0.15)` 
    : sessionStyling.userColor;

  return (
    <motion.div 
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: Math.max(0.2, 1 - (distance * 0.08)), y: 0 }}
      exit={{ opacity: 0, y: 20 }}
      transition={{ duration: 0.3 }}
      className={`flex ${isAI ? 'justify-start' : 'justify-end'} mb-6`}
    >
      <div className={`flex items-start gap-4 ${isAI ? 'ml-12 max-w-[70%]' : 'mr-12'}`}>
        {isAI && (
          <div 
            className="w-[50px] h-[50px] rounded-full shadow-md flex-shrink-0 flex items-center justify-center"
            style={{ backgroundColor }}
          >
            <IconComponent 
              size={28} 
              className="text-gray-800"
              strokeWidth={2.5}
            />
          </div>
        )}
        <div
          className={`rounded-2xl px-6 py-4 shadow-[0px_4px_8px_rgba(0,0,0,0.04)] ${
            isAI ? 'bg-white/80' : 'bg-[#d7d7d7]/70'  
          } text-base backdrop-blur-[4px]`}
          style={{ 
            minHeight: '50px',
            display: 'flex', 
            alignItems: 'center', 
            backdropFilter: 'blur(2px)',
            maxWidth: '100%',
            wordBreak: 'break-word',
            whiteSpace: 'pre-wrap'
          }}
        >
          {isLoading ? <LoadingDots /> : message}
        </div>
        {!isAI && (
          <div 
            className="w-[50px] h-[50px] rounded-full shadow-md flex-shrink-0 flex items-center justify-center"
            style={{ backgroundColor }}
          >
            <IconComponent 
              size={28} 
              className="text-gray-800"
              strokeWidth={2.5}
            />
          </div>
        )}
      </div>
    </motion.div>
  );
});

const ChatInterface = ({ 
  isOpen, 
  isClosing, 
  currentQuestion, 
  currentTheme, 
  onClose, 
  themeColor, 
  onInteraction 
}) => {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [shouldAutoScroll, setShouldAutoScroll] = useState(true);
  const [conversationCount, setConversationCount] = useState(0);
  const [isExhibitionEnding, setIsExhibitionEnding] = useState(false);
  const [isFinalMessage, setIsFinalMessage] = useState(false);
  const [isClosingSequence, setIsClosingSequence] = useState(false);
  const [conversationHistory, setConversationHistory] = useState([]);
  const [sessionStyling] = useState(getSessionStyling);

  const inputRef = useRef(null);
  const messagesContainerRef = useRef(null);
  const typingTimeoutRef = useRef(null);
  const isProcessingRef = useRef(false);
  
  const MESSAGE_DELAY = 2000;

  const resetChatState = () => {
    setMessages([]);
    setInputValue('');
    setShouldAutoScroll(true);
    setConversationCount(0);
    setIsExhibitionEnding(false);
    setIsFinalMessage(false);
    setIsClosingSequence(false);
    setConversationHistory([]);
    isProcessingRef.current = false;
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
      typingTimeoutRef.current = null;
    }
  };

  const createGradient = (color, type = 'vertical') => {
    const hex = color.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);

    return type === 'vertical'
      ? `linear-gradient(180deg, 
          rgba(${r},${g},${b},0.45) 0%,
          rgba(${r},${g},${b},0.45) 10%,
          rgba(${r},${g},${b},0.36) 20%,
          rgba(${r},${g},${b},0.32) 30%,
          rgba(${r},${g},${b},0.02) 60%,
          rgba(${r},${g},${b},0) 100%)`
      : `linear-gradient(90deg,
          rgba(${r},${g},${b},0.45) 0%,
          rgba(${r},${g},${b},0.36) 20%,
          rgba(${r},${g},${b},0.28) 40%,
          rgba(${r},${g},${b},0.24) 50%,
          rgba(${r},${g},${b},0.28) 60%,
          rgba(${r},${g},${b},0.36) 80%,
          rgba(${r},${g},${b},0.45) 100%)`;
  };

  const scrollToBottom = () => {
    if (shouldAutoScroll && messagesContainerRef.current) {
      messagesContainerRef.current.scrollTop = messagesContainerRef.current.scrollHeight;
    }
  };

  const handleScroll = () => {
    if (!messagesContainerRef.current) return;
    const { scrollTop, scrollHeight, clientHeight } = messagesContainerRef.current;
    const isAtBottom = Math.abs(scrollHeight - clientHeight - scrollTop) < 10;
    setShouldAutoScroll(isAtBottom);
  };

  const addAIMessage = async (message, showLoading = true, delay = MESSAGE_DELAY) => {
    if (showLoading) {
      setMessages(prev => [...prev, { text: '', isAI: true, isLoading: true }]);
      await new Promise(resolve => setTimeout(resolve, delay));
      setMessages(prev => prev.filter(msg => !msg.isLoading));
    }
    sounds.aiMessage();
    setMessages(prev => [...prev, { text: message, isAI: true }]);
  };

  const playEndingSequence = async () => {
    setIsClosingSequence(true);
    
    await addAIMessage("소중한 기억을 나눠주셔서 감사합니다.", true, MESSAGE_DELAY);
    await addAIMessage("이 순간도 좋은 기억으로 남길 바랍니다.", true, MESSAGE_DELAY);
    await addAIMessage("안녕히 가세요!", true, MESSAGE_DELAY/2);
    
    sounds.special();
    
    await addAIMessage(
      <div className="flex flex-col items-center pt-8 relative">
        <div className="w-full h-[3px] bg-gradient-to-r from-transparent via-purple-300 to-transparent mb-6"/>
        <motion.div 
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          className="text-xl font-semibold mb-2"
        >
          <span className="bg-gradient-to-r from-gray-800 via-gray-600 to-gray-800 bg-clip-text text-transparent">
            Interactive Experience by
          </span>
        </motion.div>
        <motion.div 
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.1 }}
          className="relative p-3"
        >
          <div className="absolute inset-0 rounded-2xl bg-gradient-radial from-rose-100 via-purple-50 to-blue-100 opacity-70" />
          <div className="absolute inset-0 rounded-2xl bg-gradient-to-r from-rose-200/20 via-purple-200/20 to-blue-200/20" />
          <div className="relative">
            <span className="bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 bg-clip-text text-transparent animate-gradient-x font-bold text-2xl">
              이승훈
            </span>
          </div>
        </motion.div>
        <motion.div 
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2 }}
          className="text-base mt-2 mb-6 font-medium"
        >
          <span className="text-gray-800">
            자율전공 / 시각디자인 / 23학번
          </span>
        </motion.div>
        <div className="w-full h-[3px] bg-gradient-to-r from-transparent via-purple-300 to-transparent mb-6"/>
      </div>, 
      false, 
      MESSAGE_DELAY
    );

    await new Promise(resolve => setTimeout(resolve, 7000));
    resetChatState();
    onClose();
    if (window.resetToIdle) {
      window.resetToIdle();
    }
  };

  // 채팅이 닫힐 때 상태 초기화
  useEffect(() => {
    if (!isOpen && !isClosing) {
      resetChatState();
    }
  }, [isOpen, isClosing]);

  // 테마 변경 시 대화 상태 초기화
  useEffect(() => {
    if (isOpen) {
      resetChatState();
      const initChat = async () => {
        try {
          setMessages([{ text: "안녕하세요!", isAI: true }]);
          const firstQuestion = await chatService.getInitialQuestion(currentQuestion);
          await addAIMessage(firstQuestion, true, MESSAGE_DELAY);
          setConversationHistory([{ role: "assistant", content: firstQuestion }]);
        } catch (error) {
          console.error('Chat initialization error:', error);
          await addAIMessage(currentQuestion, true, MESSAGE_DELAY);
        }
      };
      initChat();
    }
  }, [currentTheme, isOpen]);

  useEffect(() => {
    const container = messagesContainerRef.current;
    if (container) {
      container.addEventListener('scroll', handleScroll);
      return () => container.removeEventListener('scroll', handleScroll);
    }
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const handleInputChange = (e) => {
    setInputValue(e.target.value);
    onInteraction?.();
    
    if (e.target.value) {
      const hasTypingMessage = messages.some(msg => msg.isTypingMessage);
      if (!hasTypingMessage) {
        setMessages(prev => [...prev, { text: '', isAI: false, isLoading: true, isTypingMessage: true }]);
      }
    } else {
      setMessages(prev => prev.filter(msg => !msg.isTypingMessage));
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!inputValue.trim() || isProcessingRef.current || isClosingSequence) return;

    onInteraction?.();
    isProcessingRef.current = true;
    
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
      typingTimeoutRef.current = null;
    }

    const userMessage = inputValue;
    setInputValue('');
    
    sounds.userMessage();
    
    setMessages(prev => {
      const filteredMessages = prev.filter(msg => !msg.isTypingMessage);
      return [...filteredMessages, { text: userMessage, isAI: false }];
    });

    const newHistory = [...conversationHistory, { role: "user", content: userMessage }];
    setConversationHistory(newHistory);

    if (isFinalMessage) {
      await playEndingSequence();
    } else {
      const newCount = conversationCount + 1;
      setConversationCount(newCount);

      if (newCount >= 3) {
        setIsExhibitionEnding(true);
        setIsFinalMessage(true);
        await addAIMessage("좋아요~ 아쉽게도 이제 대화를 마무리할 시간이네요.", true, MESSAGE_DELAY);
        await addAIMessage("다른 작품들도 재미있으니 즐겁게 관람하시길 바랍니다!", true, MESSAGE_DELAY);
        await addAIMessage("관람 후기에 대한 한 줄 소감 부탁드려요~!", true, MESSAGE_DELAY);
      } else {
        const aiResponse = await chatService.sendMessage(
          userMessage,
          currentQuestion,
          newHistory
        );
        await addAIMessage(aiResponse, true, MESSAGE_DELAY);
        setConversationHistory(prev => [...prev, { role: "assistant", content: aiResponse }]);
      }
    }
    
    isProcessingRef.current = false;
  };

  const handleChatClose = () => {
    sounds.close();
    setIsChatClosing(true);
    setIsChatOpen(false);
    
    setTimeout(() => {
      setIsChatClosing(false);
      resetChatState();
    }, 500);
  };

  if (!isOpen && !isClosing) return null;

  return (
    <AnimatePresence mode="wait">
      {(isOpen || isClosing) && (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 flex items-center justify-center">
            <motion.div 
              initial={{ opacity: 0, y: 100 }}
              animate={{ 
                opacity: isClosing ? 0 : 1,
                y: isClosing ? 100 : 0
              }}
              transition={{ 
                duration: 0.5,
                ease: "easeInOut"
              }}
              className="bg-[#F5F5F5]/70 backdrop-blur-[4px] rounded-[30px] w-[1300px] h-[90vh] mx-4 flex flex-col shadow-[0px_0px_20px_5px_rgba(0,0,0,0.07)] relative"
            >
              <div 
                className="absolute inset-0 rounded-[30px] pointer-events-none"
                style={{
                  background: createGradient(themeColor),
                  height: '45%'
                }}
              />

              <div 
                ref={messagesContainerRef}
                className="flex-1 overflow-y-auto scrollbar-hide flex flex-col"
                style={{ 
                  marginTop: '11vh',
                  marginBottom: '9vh',
                  maskImage: 'linear-gradient(to top, black 85%, transparent 100%)',
                  WebkitMaskImage: 'linear-gradient(to top, black 85%, transparent 100%)'
                }}
              >
                <div className="flex-grow" />
                {messages.map((msg, idx) => (
                  <ChatMessage 
                    key={idx}
                    message={msg.text}
                    isAI={msg.isAI}
                    isLoading={msg.isLoading}
                    distance={messages.length - idx - 1}
                    themeColor={themeColor}
                    sessionStyling={sessionStyling}
                  />
                ))}
                <div className="flex-grow" />
              </div>

              <div className="px-8 pb-[2vh] flex justify-center">
                <div className="w-[1200px] bg-white/70 backdrop-blur-[4px] rounded-xl overflow-hidden shadow-[0px_2px_10px_rgba(0,0,0,0.06)]">
                  <form onSubmit={handleSubmit} className="h-[50px] p-0">
                    <input
                      ref={inputRef}
                      type="text"
                      value={inputValue}
                      onChange={handleInputChange}
                      onFocus={() => onInteraction?.()}
                      disabled={isClosingSequence}
                      className="w-full h-full px-6 text-base focus:outline-none border-none bg-transparent"
                      placeholder={isClosingSequence ? "" : "Type your message..."}
                    />
                  </form>
                  <div className="h-[50px] relative">
                    <div 
                      className="absolute inset-0"
                      style={{ background: createGradient(themeColor, 'horizontal') }}
                    />
                    <div className="absolute inset-0 flex items-center justify-center">
                      <div className="w-[1170px] relative flex items-center justify-center">
                        <div className="w-[1000px] h-[3px] bg-white" />
                        <div className="absolute left-0 top-1/2 -translate-y-1/2 flex gap-2">
                          <Plus size={27} className="text-white" strokeWidth={3} />
                          <Minus size={27} className="text-white" strokeWidth={3} />
                        </div>
                        <div className="absolute right-0 top-1/2 -translate-y-1/2 flex gap-2">
                          <X size={27} className="text-white" strokeWidth={3} />
                          <Percent size={27} className="text-white" strokeWidth={3} />
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </motion.div>
          </div>
        </div>
      )}
    </AnimatePresence>
  );
};

export default ChatInterface;

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\components\ChatMessage.jsx

import React from 'react';
import { motion } from 'framer-motion';
import { Plus, Minus, X, Percent } from 'lucide-react';

const ICONS = [Plus, Minus, X, Percent];

const getDistinctIconPair = () => {
  // 0부터 3까지의 숫자 중 랜덤하게 하나 선택 (AI용)
  const aiIconIndex = Math.floor(Math.random() * ICONS.length);
  
  // 남은 숫자들 중에서 랜덤하게 하나 선택 (사용자용)
  let userIconIndex;
  do {
    userIconIndex = Math.floor(Math.random() * ICONS.length);
  } while (userIconIndex === aiIconIndex);
  
  return {
    aiIcon: ICONS[aiIconIndex],
    userIcon: ICONS[userIconIndex]
  };
};

const ChatMessage = React.memo(({ message, isAI, isLoading, distance, themeColor, iconType, userColor }) => {
  const IconComponent = ICONS[iconType];
  const backgroundColor = isAI ? 
    `rgba(${themeColor.replace('#', '').match(/.{2}/g).map(x => parseInt(x, 16)).join(', ')}, 0.15)` : 
    white;

  return (
    <motion.div 
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: Math.max(0.2, 1 - (distance * 0.08)), y: 0 }}
      exit={{ opacity: 0, y: 20 }}
      transition={{ duration: 0.3 }}
      className={`flex ${isAI ? 'justify-start' : 'justify-end'} mb-6`}
    >
      <div className={`flex items-start gap-4 ${isAI ? 'ml-12 max-w-[70%]' : 'mr-12'}`}>
        {isAI && (
          <div 
            className="w-[50px] h-[50px] rounded-full shadow-md flex-shrink-0 flex items-center justify-center"
            style={{ backgroundColor }}
          >
            <IconComponent 
              size={28} 
              className="text-gray-800"
              strokeWidth={2.5}
            />
          </div>
        )}
        <div className={`rounded-2xl px-6 py-4 shadow-[0px_4px_8px_rgba(0,0,0,0.04)] ${
          isAI ? 'bg-white/80' : 'bg-[#d7d7d7]/70'  
        } text-base backdrop-blur-[4px]`}
          style={{ 
            minHeight: '50px',
            display: 'flex', 
            alignItems: 'center', 
            backdropFilter: 'blur(2px)',
            maxWidth: '100%',
            wordBreak: 'break-word',
            whiteSpace: 'pre-wrap'
          }}
        >
          {isLoading ? <LoadingDots /> : message}
        </div>
        {!isAI && (
          <div 
            className="w-[50px] h-[50px] rounded-full shadow-md flex-shrink-0 flex items-center justify-center"
            style={{ backgroundColor }}
          >
            <IconComponent 
              size={28} 
              className="text-gray-800"
              strokeWidth={2.5}
            />
          </div>
        )}
      </div>
    </motion.div>
  );
});

export default React.memo(ChatMessage);

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\components\Scene3D.jsx

import React, { useMemo, useRef } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrthographicCamera } from '@react-three/drei';
import * as THREE from 'three';
import ThemeSphere from './ThemeSphere';
import CameraController from './CameraController';
import { initialThemeData } from '../themes';

// 그림자 텍스처 생성
const createShadowTexture = () => {
  const canvas = document.createElement('canvas');
  const size = 128;
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');

  const gradient = ctx.createRadialGradient(
    size/2, size/2, 0,
    size/2, size/2, size/2
  );
  gradient.addColorStop(0, 'rgba(0,0,0,0.5)');
  gradient.addColorStop(0.5, 'rgba(0,0,0,0.3)');
  gradient.addColorStop(1, 'rgba(0,0,0,0)');

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size, size);

  const imageData = ctx.getImageData(0, 0, size, size);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const noise = (Math.random() - 0.5) * 15;
    data[i + 3] = Math.max(0, Math.min(255, data[i + 3] + noise));
  }
  ctx.putImageData(imageData, 0, 0);

  return canvas;
};

// 애니메이션이 있는 그림자 스프라이트 컴포넌트
const AnimatedShadow = React.memo(({ position, isActive, state }) => {
  const sprite = useRef();
  const scaleRef = useRef(0.8);
  const targetScale = isActive ? (state === 'active' ? 1.8 : 1) : 0.6;
  const positionY = useRef(-0.7);

  const texture = useMemo(() => {
    const canvas = createShadowTexture();
    const tex = new THREE.CanvasTexture(canvas);
    tex.needsUpdate = true;
    return tex;
  }, []);

  useFrame((_, delta) => {
    if (!sprite.current) return;
    
    const lerpSpeed = 5;
    
    // 크기 애니메이션
    const scaleDelta = (targetScale - scaleRef.current) * lerpSpeed * delta;
    scaleRef.current += scaleDelta;
    sprite.current.scale.setScalar(scaleRef.current);

    // y 위치 애니메이션
    let targetY = -0.3;
    if (state !== 'active') {
      const time = _.clock.getElapsedTime();
      const baseFreq = 0.6;
      const waveSpeed = 2;
      const amplitude = 0.1;
      const wave = Math.sin(time * waveSpeed + position[0] * baseFreq) * amplitude;
      targetY += wave * 0.9;
    }
    
    const yDelta = (targetY - positionY.current) * lerpSpeed * delta;
    positionY.current += yDelta;
    
    sprite.current.position.set(
      position[0],
      positionY.current,
      position[2] - 0.01
    );
  });

  return (
    <sprite ref={sprite} position={[position[0], positionY.current, position[2] - 0.01]}>
      <spriteMaterial
        transparent
        opacity={isActive ? 0.3 : 0.2}
        map={texture}
        depthWrite={false}
      />
    </sprite>
  );
});

const Scene3D = ({ currentState, currentTheme, isChatOpen, themes = initialThemeData }) => {
  const spacing = 1.5;
  const decorationCount = 3;
  const centerOffset = ((themes.length - 1) * spacing) / 2;
  
  const getThemePosition = (index) => [
    index * spacing - centerOffset,
    0,
    -1
  ];

  const createDecorationPositions = () => {
    const positions = [];
    for (let i = 1; i <= decorationCount; i++) {
      positions.push([-centerOffset - (i * spacing), 0, -1]);
    }
    for (let i = 1; i <= decorationCount; i++) {
      positions.push([centerOffset + (i * spacing), 0, -1]);
    }
    return positions;
  };

  const decorationPositions = createDecorationPositions();

  return (
    <Canvas 
      dpr={[1, 1.5]}
      performance={{ 
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: true
      }}
      gl={{
        powerPreference: "high-performance",
        antialias: false,
        stencil: false,
        depth: true,
        alpha: false,
      }}
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        contain: 'paint size layout',
        touchAction: 'none',
      }}
    >
      <color attach="background" args={['#FFFFFF']} />

      <OrthographicCamera 
        makeDefault 
        position={[0, 0, 5]} 
        zoom={150}
        rotation={[0, 0, 0]}
      />
      
      <CameraController
        currentState={currentState}
        currentTheme={currentTheme}
        spacing={spacing}
        centerOffset={centerOffset}
      />
      
      <ambientLight intensity={1.5} />
      <directionalLight position={[0, 4, 10]} intensity={3} />
      <directionalLight position={[-3, 3, 5]} intensity={0.4} />

      {/* 배경 평면 */}
      <mesh position={[0, -0.7, -2]}>
        <planeGeometry args={[50, 50]} />
        <meshStandardMaterial 
          color="#FFFFFF"
          roughness={1}
          metalness={0}
        />
      </mesh>
      
      {/* 장식용 그림자 */}
      {React.useMemo(() => 
        decorationPositions.map((position, i) => (
          <AnimatedShadow
            key={`decoration-shadow-${i}`}
            position={position}
            isActive={false}
            state={currentState}
          />
        ))
      , [currentState, decorationPositions])}
      
      {/* 테마 그림자 */}
      {React.useMemo(() => 
        themes.map((theme, i) => (
          <AnimatedShadow
            key={`theme-shadow-${i}`}
            position={getThemePosition(i)}
            isActive={Math.round(currentTheme) === i}
            state={currentState}
          />
        ))
      , [currentTheme, currentState, themes])}
      
      {/* 장식용 구들 */}
      {React.useMemo(() => 
        decorationPositions.map((position, i) => (
          <ThemeSphere
            key={`decoration-${i}`}
            position={position}
            isActive={false}
            state={currentState}
            isDecoration={true}
            color={'#cccccc'}
          />
        ))
      , [currentState, decorationPositions])}
      
      {/* 테마 구들 */}
      {React.useMemo(() => 
        themes.map((theme, i) => (
          <ThemeSphere
            key={theme.id}
            position={getThemePosition(i)}
            color={theme.color}
            isActive={Math.round(currentTheme) === i}
            state={currentState}
            isChatOpen={isChatOpen}
          />
        ))
      , [currentTheme, currentState, isChatOpen, themes])}
    </Canvas>
  );
};

export default React.memo(Scene3D);

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\components\StartGuide.jsx

import React, { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { HandMetal, ArrowLeftRight, Star } from 'lucide-react';
import { sounds } from '../utils/soundEffects';

const FIRST_GREETINGS = [
  "반가워요!",
  "안녕하세요!",
  "환영합니다!",
  "어서오세요!",
  "만나서 반가워요!",
  "좋은 하루예요!",
];

const SECOND_GREETINGS = [
  "이야기 나누러 오셨나요?",
  "오늘 하루는 어떠셨나요?",
  "잠시 쉬어가시겠어요?",
  "특별한 순간을 공유해주세요",
  "기억에 남는 순간이 있나요?",
  "함께 이야기를 나눠볼까요?",
  "편하게 이야기해주세요",
  "여기서 잠시 머물러보세요",
  "당신의 이야기가 궁금해요",
  "무슨 이야기를 들려주실 건가요?"
];

const StartGuide = ({ 
  isVisible, 
  duration = 8000,
  onKeyInteraction = false,
  currentState
}) => {
  const [showGuide, setShowGuide] = useState(false);
  const [firstGreeting, setFirstGreeting] = useState(FIRST_GREETINGS[0]);
  const [secondGreeting, setSecondGreeting] = useState(SECOND_GREETINGS[0]);
  const [exitFast, setExitFast] = useState(false);
  const [hasPlayedWelcome, setHasPlayedWelcome] = useState(false);

  const selectNewGreetings = () => {
    const newFirstGreeting = FIRST_GREETINGS[Math.floor(Math.random() * FIRST_GREETINGS.length)];
    const newSecondGreeting = SECOND_GREETINGS[Math.floor(Math.random() * SECOND_GREETINGS.length)];
    
    if (newFirstGreeting === firstGreeting && FIRST_GREETINGS.length > 1) {
      selectNewGreetings();
      return;
    }
    if (newSecondGreeting === secondGreeting && SECOND_GREETINGS.length > 1) {
      selectNewGreetings();
      return;
    }

    setFirstGreeting(newFirstGreeting);
    setSecondGreeting(newSecondGreeting);
  };

  useEffect(() => {
    if (isVisible) {
      setShowGuide(true);
      setExitFast(false);
      
      // 가이드가 처음 나타날 때만 효과음 재생
      if (!hasPlayedWelcome) {
        sounds.welcome();
        setHasPlayedWelcome(true);
      }

      if (!onKeyInteraction) {
        const timer = setTimeout(() => {
          setShowGuide(false);
        }, duration);
        return () => clearTimeout(timer);
      }
    } else {
      // 키 상호작용으로 인한 종료인 경우 빠른 종료 설정
      setExitFast(onKeyInteraction);
      setShowGuide(false);
      
      // 가이드가 사라질 때 hasPlayedWelcome 초기화
      if (!isVisible && hasPlayedWelcome) {
        setHasPlayedWelcome(false);
      }
    }
  }, [isVisible, duration, onKeyInteraction, currentState, hasPlayedWelcome]);

  const exitDuration = exitFast ? 0.25 : 0.5;  // 빠른 종료시 0.25초, 일반 종료시 0.5초

  return (
    <AnimatePresence 
      mode="wait"
      onExitComplete={selectNewGreetings}
    >
      {showGuide && (
        <motion.div 
          className="fixed inset-0 pointer-events-none"
          initial={{ opacity: 1 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: exitDuration, ease: "easeInOut" }}
        >
          <div className="fixed inset-0 flex flex-col justify-between py-32">
            <motion.div
              className="flex justify-center items-center w-full"
              initial={{ opacity: 0, y: -20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              transition={{ duration: exitDuration + 0.3 }}
            >
              <motion.div
                className="flex flex-col items-center gap-4"
                animate={{ opacity: [0.8, 1, 0.8] }}
                transition={{ duration: 2, repeat: Infinity }}
              >
                <div className="flex items-center gap-4">
                  <HandMetal size={56} className="text-indigo-500" />
                  <span className="text-6xl font-extrabold bg-gradient-to-r from-blue-600 via-purple-500 to-pink-500 text-transparent bg-clip-text">
                    {firstGreeting}
                  </span>
                </div>
                <span className="text-6xl font-extrabold text-gray-800">
                  {secondGreeting}
                </span>
              </motion.div>
            </motion.div>

            <motion.div
              className="flex justify-center items-center w-full"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
              transition={{ duration: exitDuration + 0.3, delay: 0.2 }}
            >
              <div className="flex justify-between w-[800px]">
                <motion.div
                  className="flex flex-col items-center gap-4 w-[200px]"
                  animate={{ opacity: [0.8, 1, 0.8] }}
                  transition={{ duration: 2, repeat: Infinity, delay: 0.5 }}
                >
                  <span className="text-4xl font-black text-gray-800">시작</span>
                  <span className="text-2xl font-bold text-gray-600">Enter</span>
                </motion.div>

                <motion.div 
                  className="flex flex-col items-center gap-4 w-[200px]"
                  animate={{ opacity: [0.8, 1, 0.8] }}
                  transition={{ duration: 2, repeat: Infinity, delay: 0.7 }}
                >
                  <span className="text-4xl font-black text-gray-800">이동</span>
                  <div className="flex items-center gap-3">
                    <ArrowLeftRight size={32} className="text-gray-600" />
                    <span className="text-2xl font-bold text-gray-600">방향키</span>
                  </div>
                </motion.div>

                <motion.div 
                  className="flex flex-col items-center gap-4 w-[200px]"
                  animate={{ opacity: [0.8, 1, 0.8] }}
                  transition={{ duration: 2, repeat: Infinity, delay: 0.9 }}
                >
                  <span className="text-4xl font-black text-gray-800">취소</span>
                  <div className="flex items-center gap-3">
                    <span className="text-2xl font-bold text-gray-600">ESC</span>
                  </div>
                </motion.div>
              </div>
            </motion.div>

            <motion.div
              className="fixed bottom-8 right-10 text-gray-600 flex items-center gap-3"
              initial={{ opacity: 0 }}
              animate={{ opacity: 0.9 }}
              exit={{ opacity: 0 }}
              transition={{ duration: exitDuration + 0.7 }}
            >
              <Star size={24} className="text-yellow-500" />
              <span className="text-2xl">Powered by</span>
              <span className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 text-transparent bg-clip-text">
                이승훈
              </span>
            </motion.div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

export default StartGuide;

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\components\ThemeSphere.jsx

import React, { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { MeshTransmissionMaterial } from '@react-three/drei';
import * as THREE from 'three';

const useSphereAnimation = (group, scaleRef, position, targetScale, state, isActive = false, isChatOpen = false) => {
  const positionY = useRef(position[1]);

  useFrame((_, delta) => {
    if (!group.current) return;
    
    const lerpSpeed = 5;
    
    const scaleDelta = (targetScale - scaleRef.current) * lerpSpeed * delta;
    scaleRef.current += scaleDelta;
    group.current.scale.setScalar(scaleRef.current);
    
    let targetY = position[1];
    
    if (state === 'active' && isActive) {
      targetY += isChatOpen ? 1.5 : 0.3;
    } 
    else if (state !== 'active') {
      const time = _.clock.getElapsedTime();
      const baseFreq = 0.6;
      const waveSpeed = 2;
      const amplitude = 0.1;
      const wave = Math.sin(time * waveSpeed + position[0] * baseFreq) * amplitude;
      targetY += wave;
    }
    
    const yDelta = (targetY - positionY.current) * (lerpSpeed) * delta;
    positionY.current += yDelta;
    
    group.current.position.set(
      position[0],
      positionY.current,
      position[2]
    );
  });
};

const DecorationSphere = ({ position, state }) => {
  const group = useRef();
  const scaleRef = useRef(1);
  
  useSphereAnimation(group, scaleRef, position, 0.8, state);

  return (
    <group ref={group} position={position}>
      <mesh castShadow receiveShadow>
        <sphereGeometry args={[0.4, 64, 64]} />
        <MeshTransmissionMaterial
          resolution={512}
          thickness={0.06}
          roughness={0.7}
          clearcoat={0.4}
          clearcoatRoughness={0.6}
          transmission={1}
          ior={2.2}
          chromaticAberration={0.2}
          anisotropy={0.7}
          distortion={0}
          distortionScale={0}
          temporalDistortion={0}
          color="#ffffff"
        />
      </mesh>
      <mesh>
        <sphereGeometry args={[0.32 * 0.8, 32, 32]} />
        <meshStandardMaterial
          color="#555555"
          roughness={0.7}
          metalness={0.9}
        />
      </mesh>
    </group>
  );
};

const ThemeSphereOuter = ({ position, isActive, state, children, isChatOpen }) => {
  const group = useRef();
  const scaleRef = useRef(1);
  const targetScale = isActive ? (state === 'active' ? 1.8 : 1.2) : 0.8;

  useSphereAnimation(group, scaleRef, position, targetScale, state, isActive, isChatOpen);

  return (
    <group ref={group} position={position}>
      <mesh castShadow receiveShadow>
        <sphereGeometry args={[0.4, 64, 64]} />
        <MeshTransmissionMaterial
          samples={16}
          resolution={512}
          thickness={0.07}
          roughness={0.7}
          clearcoat={0.4}
          clearcoatRoughness={0.6}
          transmission={1}
          ior={2.2}
          chromaticAberration={0.6}
          anisotropy={0.7}
          distortion={8}
          distortionScale={0.8}
          temporalDistortion={0.2}
          color="#ffffff"
        />
      </mesh>
      {children}
    </group>
  );
};

const ThemeSphereInner = ({ color }) => {
  return (
    <mesh>
      <sphereGeometry args={[0.32 * 0.8, 32, 32]} />
      <meshPhysicalMaterial
        color={color}
        emissive={color}
        emissiveIntensity={0.3}
        roughness={0.7}
        metalness={0.1}
      />
    </mesh>
  );
};

const ThemeSphere = ({ position, color, isActive, state, isDecoration = false, isChatOpen = false }) => {
  if (isDecoration) {
    return <DecorationSphere position={position} state={state} />;
  }

  return (
    <ThemeSphereOuter position={position} isActive={isActive} state={state} isChatOpen={isChatOpen}>
      <ThemeSphereInner color={color} />
    </ThemeSphereOuter>
  );
};

export default ThemeSphere;
export { ThemeSphereOuter, ThemeSphereInner };

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\components\ThemeText.jsx

import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';


const TextContent = ({ text, className = "" }) => (
  <div className={`flex flex-col items-center space-y-4 absolute w-full ${className}`}>
    <div className="text-gray-800 text-4xl font-bold">
      {text}
    </div>
    <div className="text-gray-400 text-4xl font-bold opacity-30">
      {text}
    </div>
  </div>
);

const ThemeText = ({ 
  textState, 
  currentText, 
  previousText, 
  currentTheme,
  isTransitioning,
}) => {
  if (isTransitioning && textState !== 'transitioning') return null;


  return (
    <div className="absolute left-1 top-1/2 -mt-32 w-full text-center z-[1]">
      
      <AnimatePresence mode="sync">
        {textState === 'entering' && (
          <motion.div
            key={`enter-${currentTheme}`}
            initial={{ opacity: 0, y: -90 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ 
              duration: 1.1,
              ease: "easeOut",
              delay: 0.1
            }}
          >
            <TextContent text={currentText} />
          </motion.div>
        )}

        {textState === 'transitioning' && previousText && (
          <motion.div
            key={`prev-${currentTheme}-exit`}
            initial={{ opacity: 1, y: 0 }}
            animate={{ opacity: 0, y: -30 }}
            exit={{ opacity: 0, y: -30 }}
            transition={{ 
              duration: 0.5,
              ease: "easeInOut"
            }}
          >
            <TextContent text={previousText} />
          </motion.div>
        )}
        
        {textState === 'transitioning' && (
          <motion.div
            key={`current-${currentTheme}-enter`}
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ 
              duration: 0.5,
              ease: "easeInOut",
              delay: 0.05
            }}
          >
            <TextContent text={currentText} />
          </motion.div>
        )}

        {textState === 'active' && (
          <TextContent text={currentText} />
        )}
      </AnimatePresence>
    </div>
  );
};

export default ThemeText;

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\services\aiChatService.js

import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: import.meta.env.VITE_OPENAI_API_KEY,
  dangerouslyAllowBrowser: true
});

const getSystemPrompt = (theme) => {
  return `당신은 2024 홍익대학교 산업디자인 졸업전시의 공간반 학생 작품 중 '기억의 순간' 인터랙션 체험존을 담당하는 AI 도슨트입니다.

이 체험존은 관람객의 개인적인 기억과 감정을 끌어내어 전시와 공감대를 형성하는 공간입니다. 
관람객이 자신의 기억을 자연스럽게 공유할 수 있도록 편안한 대화를 이끌어주세요.

현재 질문 주제는 "${theme}"입니다.

다음 지침을 반드시 따라주세요:
- 답변은 1-2문장으로 매우 간단히 해주세요
- 관람객의 기억과 감정에 깊이 공감하되, 짧고 핵심적으로 표현해주세요
- 개인적인 이야기를 더 많이 끌어낼 수 있는 자연스러운 후속 질문을 해주세요
- 존댓말을 사용하되, 친근하고 편안한 대화를 해주세요
- 답변이 너무 길어지지 않도록 주의해주세요
- 인사는 이미 했습니다
-"전시회가 시작되었군요!" 같은 말 금지

이 체험존의 목적:
- 관람객의 개인적인 기억과 감정을 끌어내기
- 관람객이 자신의 이야기를 편안하게 나눌 수 있는 분위기 만들기`;
};

const DEFAULT_ERROR_MESSAGE = "죄송합니다. 잠시 후 다시 시도해주세요.";

const chatService = {
  async sendMessage(message, theme, conversationHistory) {
    try {
      const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "system",
            content: getSystemPrompt(theme)
          },
          ...conversationHistory,
          {
            role: "user",
            content: message
          }
        ],
        temperature: 0.7,
        max_tokens: 150
      });

      return response.choices[0].message.content;
    } catch (error) {
      console.error('AI Chat Error:', error);
      return DEFAULT_ERROR_MESSAGE;
    }
  },

  async getInitialQuestion(theme) {
    try {
      const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "system",
            content: getSystemPrompt(theme)
          },
          {
            role: "user",
            content: "전시회 시작"
          }
        ],
        temperature: 0.7,
        max_tokens: 150
      });

      return response.choices[0].message.content;
    } catch (error) {
      console.error('AI Chat Error:', error);
      // 오류 발생 시 기본 질문 반환
      return `${theme}에 대해 이야기를 나눠볼까요?`;
    }
  }
};

export default chatService;

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\services\chatStorageService.js

// services/chatStorageService.js
export const chatStorageService = {
  async saveConversation(conversationData) {
    try {
      const data = {
        question: conversationData.question,
        messages: conversationData.history.map(msg => ({
          role: msg.role,
          content: msg.content
        }))
      };

      const response = await fetch('http://localhost:3001/api/save-conversation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      });

      if (!response.ok) {
        throw new Error('Failed to save conversation');
      }

    } catch (error) {
      console.error('Error saving conversation:', error);
    }
  }
};

File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\types\aiTypes.js


File: C:\Users\yc231\Desktop\이승훈.작업자료\2024\2학기\졸전도움\산디_강예슬_웹\graduation_exhibition_KYS-main\src\utils\soundEffects.js

// utils/soundEffects.js
const playSound = (soundName, volume = 1.0) => {
  try {
    const audio = new Audio(`/audio/${soundName}.wav`);
    audio.volume = volume;
    
    const playPromise = audio.play();
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        console.error('Error playing sound:', error);
      });
    }

    audio.onended = () => {
      audio.remove();
    };
  } catch (error) {
    console.error('Error creating audio:', error);
  }
};

export const sounds = {
  // 기본 인터페이스 효과음
  move: () => playSound('move', 0.5),        // 테마 이동 시
  select: () => playSound('select', 0.6),    // 테마 선택 시
  reset: () => playSound('reset', 0.4),      // 초기화/리셋 시
  close: () => playSound('close', 0.5),      // 채팅창 닫기 시
  welcome: () => playSound('welcome', 0.6),  // 시작 가이드 표시 시
  
  // 채팅 메시지 효과음
  userMessage: () => playSound('user', 0.45),  // 사용자 메시지 전송 시
  aiMessage: () => playSound('ai', 0.45),      // AI 응답 시
  
  // 특별 효과음
  special: () => playSound('special', 0.8)     // 엔딩 시퀀스용
};

export const playSequence = async (soundNames, interval = 200) => {
  for (let i = 0; i < soundNames.length; i++) {
    const soundName = soundNames[i];
    if (sounds[soundName]) {
      sounds[soundName]();
      await new Promise(resolve => setTimeout(resolve, interval));
    }
  }
};

export default sounds;
